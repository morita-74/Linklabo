<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ã‚¸ã‚ª</title>
    <style>
        /* ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        :root {
            --bg-color: #ffffff;
            --main-color: #000000;
            --border-color: #333333;
            --highlight-color: #555555;
            --padding: 1rem;
            --error-color: #e53935; /* èµ¤ */
            --success-color: #4caf50; /* ç·‘ */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f4f4f4;
            color: var(--main-color);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            flex-direction: column;
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ - ãƒ¢ãƒã‚¤ãƒ«ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªç¸¦é…ç½® */
        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 800px;
            padding: var(--padding);
            box-sizing: border-box;
            gap: var(--padding);
        }

        /* ãƒ­ã‚´ã‚³ãƒ³ãƒ†ãƒŠ */
        .logo-container {
            width: 100%;
            text-align: center;
            padding: 20px 0 10px; /* ä¸Šéƒ¨ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ  */
            background-color: #e0f7fa; /* èƒŒæ™¯è‰²ã‚’è¿½åŠ ã—ã¦ã€ãƒ­ã‚´ã®ã‚¨ãƒªã‚¢ã‚’æ˜ç¢ºã«ã™ã‚‹ */
            border-radius: 8px 8px 0 0;
        }

        #appLogo {
            max-width: 350px; /* ãƒ­ã‚´ã®æœ€å¤§å¹…ã‚’åºƒã’ã‚‹ */
            height: auto;
        }


        /* ãƒ„ãƒ¼ãƒ«ãƒ‘ãƒãƒ« (ä¸Šéƒ¨) */
        .tool-panel {
            display: flex;
            flex-direction: column; /* ç¸¦ã«ä¸¦ã¹ã‚‹ã‚ˆã†ã«å¤‰æ›´ */
            gap: 10px;
            padding: 10px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* ãƒ¢ãƒ¼ãƒ‰é¸æŠã¨æç”»è¨­å®šã‚’æ¨ªä¸¦ã³ã«ã™ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ */
        .top-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }


        /* ãƒ¢ãƒ¼ãƒ‰é¸æŠãƒœã‚¿ãƒ³ */
        .mode-selector {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }

        .mode-selector button {
            padding: 8px 12px;
            border: 2px solid var(--main-color);
            background-color: var(--bg-color);
            color: var(--main-color);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-weight: bold;
            flex-shrink: 0;
        }

        .mode-selector button.active,
        .mode-selector button:hover {
            background-color: var(--main-color);
            color: var(--bg-color);
        }
        
        .mode-selector button#eraseModeBtn.active {
            background-color: var(--error-color); /* æ¶ˆã—ã‚´ãƒ ã¯èµ¤ã§å¼·èª¿ */
            border-color: var(--error-color);
            color: var(--bg-color);
        }
        .mode-selector button#eraseModeBtn:hover {
            background-color: var(--error-color);
            color: var(--bg-color);
        }


        /* è¨­å®šã‚¨ãƒªã‚¢ */
        .settings-group {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            flex-grow: 1;
        }
        .settings-group label {
            white-space: nowrap;
        }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚­ã‚¹ãƒˆ/ç”»åƒãƒ‘ãƒãƒ« */
        .custom-text-panel {
            padding: 15px;
            background-color: #e3f2fd; /* è–„ã„é’ã®èƒŒæ™¯ */
            border: 1px solid #90caf9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ç”»åƒãƒ‘ãƒãƒ« (ç·‘ç³») */
        .custom-image-panel {
            background-color: #e8f5e9; 
            border: 1px solid #a5d6a7;
        }


        .custom-text-panel h3 {
            margin-top: 0;
            border-bottom: 1px solid #bbdefb;
            padding-bottom: 5px;
        }
        
        #customTextPreviewContainer {
            border: 1px dashed #78909c;
        }
        
        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ */
        .canvas-area {
            position: relative;
            width: 100%;
            padding-top: 100%; /* å¸¸ã«æ­£æ–¹å½¢ã‚’ç¶­æŒ */
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            /* ãƒ­ã‚´ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é–“éš”ã‚’èª¿æ•´ */
            margin-top: -10px; 
        }

        #designCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            touch-action: none;
        }

        /* ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ãƒ¬ãƒƒãƒˆ */
        .stamp-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 8px;
            padding: 10px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .stamp-button {
            background: none;
            border: 2px solid var(--border-color);
            border-radius: 5px;
            font-size: 24px;
            cursor: pointer;
            height: 40px;
            line-height: 40px;
            text-align: center;
            transition: transform 0.1s, background-color 0.2s;
            padding: 0;
            filter: grayscale(100%); 
        }
        
        .stamp-button img {
            max-width: 80%;
            max-height: 80%;
            vertical-align: middle;
            margin: auto;
            display: block;
        }

        .stamp-button:hover {
            transform: scale(1.1);
            background-color: #eee;
        }

        .stamp-button.selected {
            border-color: var(--highlight-color);
            box-shadow: 0 0 0 3px var(--highlight-color);
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ */
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }

        .action-button {
            flex-grow: 1;
            padding: 10px 20px;
            border: none;
            border-radius: 5ä¸€é;
            cursor: pointer;
            background-color: var(--main-color);
            color: var(--bg-color);
            font-weight: bold;
            transition: opacity 0.2s;
            max-width: 200px;
        }
        
        .action-button.danger {
            background-color: var(--error-color);
            color: var(--bg-color);
        }
        
        .action-button.layer-control {
            background-color: #34495e;
            color: white;
            padding: 5px 10px;
            font-size: 14px;
            max-width: none;
        }

        .action-button:hover {
            opacity: 0.8;
        }
        
        /* ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡ºåŠ›ã‚¨ãƒªã‚¢ */
        #outputArea {
            background-color: #fff3e0; /* è–„ã„ã‚ªãƒ¬ãƒ³ã‚¸ã®èƒŒæ™¯ */
            padding: 15px;
            border-radius: 8px;
            border: 2px dashed #ff9800;
            text-align: center;
            margin-top: 20px;
        }
        
        #outputArea h3 {
            color: #d84315;
            margin-top: 0;
        }
        
        #previewImage {
            max-width: 90%;
            height: auto;
            border: 5px solid #000; /* é€éæ€§ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®é»’æ  */
            background-color: #ccc; /* é€ééƒ¨åˆ†ãŒã‚ã‹ã‚‹ã‚ˆã†ã«ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯ */
            margin: 10px auto;
            display: block;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ (ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ã«èª¿æ•´) */
        @media (min-width: 600px) {
            body {
                align-items: center;
            }
            .container {
                padding: var(--padding) 0;
            }
            .tool-panel {
                flex-direction: row;
                flex-wrap: wrap;
            }
        }
        
        /* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚»ãƒƒãƒˆå†…ã®è¦ç´ ã‚’æ¨ªä¸¦ã³ã«ã™ã‚‹ãŸã‚ã®èª¿æ•´ */
        .settings-group fieldset {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        .settings-group fieldset > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- ãƒ­ã‚´ç”»åƒã«ç½®ãæ›ãˆ: ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒã‚’ä½¿ç”¨ã—ã€ä»£æ›¿ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿®æ­£ -->
    <div class="logo-container">
        <img src="https://placehold.co/350x50/3f51b5/ffffff?text=Linklabo+DESIGN+STUDIO" alt="Linklabo ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ã‚¸ã‚ª" id="appLogo">
    </div>

    <!-- â˜…ç§»å‹•: ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ã‚’ãƒ­ã‚´ã®ç›´ä¸‹ã«ç§»å‹• -->
    <div class="canvas-area">
        <canvas id="designCanvas"></canvas>
    </div>

    <!-- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ (Undo/Download) -->
    <div class="controls">
        <button id="undoBtn" class="action-button">â†©ï¸ å…ƒã«æˆ»ã™</button>
        <button id="downloadBtn" class="action-button">â¬‡ï¸ é€éPNGã‚’è¡¨ç¤º</button>
    </div>
    
    <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ãƒãƒ« -->
    <div class="custom-text-panel">
        <h3>ã‚«ã‚¹ã‚¿ãƒ ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ãƒ³ãƒ—ä½œæˆ (ç™½é»’)</h3>
        <div class="settings-group" style="background-color: transparent; padding: 0;">
            <label for="customTextInput">ãƒ†ã‚­ã‚¹ãƒˆ:</label>
            <input type="text" id="customTextInput" value="OK" maxlength="15" style="flex-grow: 1; padding: 5px;">
        </div>
        <div class="settings-group" style="background-color: transparent; padding: 5px 0;">
            <label for="customTextFont">ãƒ•ã‚©ãƒ³ãƒˆ:</label>
            <select id="customTextFont" style="padding: 5px;"></select>
            <label for="customTextSize">ã‚µã‚¤ã‚º:</label>
            <input type="range" id="customTextSize" min="40" max="200" value="80">
            <span id="customTextSizeValue">80</span>pt
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 10px; align-items: center;">
            <button id="generateStampBtn" class="action-button" style="background-color: #3f51b5; color: white; max-width: 250px;">ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ç”Ÿæˆã—ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã«è¿½åŠ </button>
            <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div id="customTextPreviewContainer" style="min-width: 100px; height: 50px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; overflow: hidden; padding: 5px;">
                <canvas id="customTextPreviewCanvas" width="100" height="50" style="max-width: 100%; max-height: 100%; border: 1px solid #ccc;"></canvas>
            </div>
        </div>
    </div>
    
    <!-- ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ãƒãƒ« (â˜…ã“ã“ãŒã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¦ç´ ã‚’å–ã‚Šè¾¼ã‚€éƒ¨åˆ†ã§ã™) -->
    <div class="custom-image-panel custom-text-panel" style="margin-top: 15px;">
        <h3>ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã‚¹ã‚¿ãƒ³ãƒ—ä½œæˆ (ç™½é»’å¤‰æ›)</h3>
        <p style="font-size: small; color: #388e3c; margin-top: 0;">â€»ãƒ­ã‚´ã‚„ã‚¤ãƒ©ã‚¹ãƒˆãªã©ã®**ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«**ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚è‡ªå‹•ã§ç™½é»’ï¼ˆã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚</p>
        <input type="file" id="imageFileInput" accept="image/*" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
    </div>
    
    <!-- ãƒ„ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
    <div class="tool-panel">
        <div class="top-controls">
            <!-- ãƒ¢ãƒ¼ãƒ‰é¸æŠ -->
            <div class="mode-selector">
                <button id="drawModeBtn" class="active" data-mode="draw">ğŸ¨ çµµã‚’æã</button>
                <button id="eraseModeBtn" data-mode="erase">â¬œ æ¶ˆã—ã‚´ãƒ </button>
                <button id="stampModeBtn" data-mode="stamp">âœ¨ ã‚¹ã‚¿ãƒ³ãƒ—</button>
            </div>

            <!-- æç”»è¨­å®š -->
            <div id="drawSettings" class="settings-group">
                <label for="baseLineWidth">å¤ªã•:</label>
                <!-- æœ€å°å€¤ã‚’ 0.5 ã«è¨­å®š -->
                <input type="range" id="baseLineWidth" min="0.5" max="9" step="0.1" value="1.0">
                <span id="baseLineWidthValue">1.0</span>px
                <span style="margin-left: 10px;">å¤ªã•å›ºå®šï¼ˆç­†åœ§ãªã—ï¼‰</span>
            </div>
            
            <!-- æ¶ˆã—ã‚´ãƒ è¨­å®š -->
            <div id="eraseSettings" class="settings-group" style="display: none;">
                <label for="eraseLineWidth">æ¶ˆã—ã‚´ãƒ ã®å¤ªã•:</label>
                <!-- æ¶ˆã—ã‚´ãƒ ã¯æç”»ã‚ˆã‚Šå¤ªã‚ã«è¨­å®šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ -->
                <input type="range" id="eraseLineWidth" min="5" max="50" step="1" value="15">
                <span id="eraseLineWidthValue">15</span>px
            </div>

            <!-- ã‚¹ã‚¿ãƒ³ãƒ—è¨­å®š -->
            <div id="stampSettings" class="settings-group" style="display: none; justify-content: space-between; flex-direction: column; gap: 15px;">
                
                <!-- ã‚µã‚¤ã‚º/å›è»¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
                <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center; width: 100%;">
                    <label for="stampSize">ã‚¹ã‚¿ãƒ³ãƒ—ã®åˆæœŸå¤§ãã•:</label>
                    <input type="range" id="stampSize" min="20" max="100" value="50">
                    <span id="stampSizeValue">50</span>px
                </div>
                
                <fieldset style="display:flex; flex-direction:column; padding: 10px; border: 1px solid #ccc; border-radius: 5px; width: 100%;">
                    <legend style="font-size: small; font-weight: bold;">åˆæœŸå›è»¢è¨­å®š</legend>
                    <div style="display:flex; align-items:center; flex-wrap: wrap; gap: 10px; margin-top: 5px;">
                        <label for="rotationMode">ãƒ¢ãƒ¼ãƒ‰:</label>
                        <select id="rotationMode" style="padding: 5px;">
                            <option value="random">ãƒ©ãƒ³ãƒ€ãƒ </option>
                            <option value="fixed">è§’åº¦ã‚’æŒ‡å®š</option>
                        </select>
                    </div>
                    <div id="fixedRotationControl" style="display:none; align-items: center; gap: 10px; margin-top: 5px;">
                        <label for="fixedRotationAngle">è§’åº¦ (0-359):</label>
                        <input type="range" id="fixedRotationAngle" min="0" max="359" value="0" style="flex-grow: 1;">
                        <span id="fixedRotationValue">0</span>Â°
                    </div>
                </fieldset>
                
                <!-- â˜…æ–°ã—ãè¿½åŠ : é¸æŠä¸­ã®ã‚¹ã‚¿ãƒ³ãƒ—æ“ä½œ -->
                <div id="selectedStampActions" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; width: 100%; border-top: 1px dashed #ccc; padding-top: 10px;">
                    <span style="font-weight: bold; width: 100%; text-align: center; color: #34495e;">é¸æŠä¸­ã®ã‚¹ã‚¿ãƒ³ãƒ—æ“ä½œ</span>
                    <button id="sendToBackBtn" class="action-button layer-control">â¬‡ï¸ æœ€èƒŒé¢ã¸</button>
                    <button id="sendToFrontBtn" class="action-button layer-control">â¬†ï¸ æœ€å‰é¢ã¸</button>
                    <button id="deleteStampBtn" class="action-button danger layer-control" style="background-color: var(--error-color);">ğŸ—‘ï¸ å‰Šé™¤</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ãƒ¬ãƒƒãƒˆ -->
    <div class="stamp-palette" id="stampPalette" style="display: none;">
        <!-- ã‚¹ã‚¿ãƒ³ãƒ—ãƒœã‚¿ãƒ³ãŒJSã§ã“ã“ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
    </div>

    <!-- ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡ºåŠ›ã‚¨ãƒªã‚¢ (æ‰‹å‹•ä¿å­˜ç”¨) -->
    <div id="outputArea" style="display: none;">
        <h3>ä¿å­˜ç”¨ç”»åƒãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ</h3>
        <p>ç”»åƒã‚’**å³ã‚¯ãƒªãƒƒã‚¯**ï¼ˆã‚¹ãƒãƒ›ã§ã¯**é•·æŠ¼ã—**ï¼‰ã—ã¦ã€Œ**ç”»åƒã‚’ä¿å­˜**ã€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
        <img id="previewImage" alt="ä¿å­˜ç”¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»åƒ" style="max-width: 100%; height: auto;">
        <p style="font-size: small;">â€»èƒŒæ™¯ã®ã‚°ãƒ¬ãƒ¼ã®éƒ¨åˆ†ã¯é€éã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('designCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.querySelector('.canvas-area');

        // --- UIè¦ç´  ---
        const drawModeBtn = document.getElementById('drawModeBtn');
        const eraseModeBtn = document.getElementById('eraseModeBtn'); 
        const stampModeBtn = document.getElementById('stampModeBtn');
        const drawSettingsDiv = document.getElementById('drawSettings');
        const eraseSettingsDiv = document.getElementById('eraseSettings'); 
        const stampSettingsDiv = document.getElementById('stampSettings');
        const stampPaletteDiv = document.getElementById('stampPalette');
        
        // æ–°ã—ã„è¦ç´ 
        const selectedStampActionsDiv = document.getElementById('selectedStampActions');
        const sendToBackBtn = document.getElementById('sendToBackBtn');
        const sendToFrontBtn = document.getElementById('sendToFrontBtn');
        const deleteStampBtn = document.getElementById('deleteStampBtn');
        
        const baseLineWidthInput = document.getElementById('baseLineWidth');
        const baseLineWidthValueSpan = document.getElementById('baseLineWidthValue');
        const eraseLineWidthInput = document.getElementById('eraseLineWidth'); 
        const eraseLineWidthValueSpan = document.getElementById('eraseLineWidthValue'); 
        const stampSizeInput = document.getElementById('stampSize');
        const stampSizeValueSpan = document.getElementById('stampSizeValue');

        const rotationModeSelect = document.getElementById('rotationMode');
        const fixedRotationControlDiv = document.getElementById('fixedRotationControl');
        const fixedRotationAngleInput = document.getElementById('fixedRotationAngle');
        const fixedRotationValueSpan = document.getElementById('fixedRotationValue');

        const undoBtn = document.getElementById('undoBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        
        const customTextInput = document.getElementById('customTextInput');
        const customTextFontSelect = document.getElementById('customTextFont');
        const customTextSizeInput = document.getElementById('customTextSize');
        const customTextSizeValueSpan = document.getElementById('customTextSizeValue');
        const generateStampBtn = document.getElementById('generateStampBtn');
        const customTextPreviewCanvas = document.getElementById('customTextPreviewCanvas');
        const previewCtx = customTextPreviewCanvas.getContext('2d');

        const outputArea = document.getElementById('outputArea');
        const previewImage = document.getElementById('previewImage');
        
        const imageFileInput = document.getElementById('imageFileInput'); 

        // --- ç­†åœ§ã¨é€Ÿåº¦ã«é–¢ã™ã‚‹å®šæ•° ---
        const MIN_LINE_WIDTH = 0.5;
        const MIN_PRESSURE_THRESHOLD = 0.0; 

        // --- ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š ---
        const FONT_OPTIONS = [
            { name: 'Noto Sans JP (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)', family: 'Noto Sans JP, sans-serif' },
            { name: 'Serif (æ˜æœä½“)', family: 'serif' },
            { name: 'Sans-serif (ã‚´ã‚·ãƒƒã‚¯ä½“)', family: 'sans-serif' }
        ];
        const DEFAULT_FONT_FAMILY = FONT_OPTIONS[0].family;
        
        // --- ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‡ãƒ¼ã‚¿ç®¡ç† ---
        
        const emojiStamps = [
            { type: 'â™¥', label: 'ãƒãƒ¼ãƒˆ' }, 
            { type: 'ğŸ¾', label: 'è¶³è·¡' },
            { type: 'â€', label: 'èŠ±' }, 
            { type: 'â€¢', label: 'ç‚¹' }, 
            { type: 'â˜…', label: 'æ˜Ÿ' }, 
            { type: 'âœ¶', label: 'ã‚­ãƒ©ã‚­ãƒ©' }, 
            { type: 'â˜', label: 'é£¾ã‚Š' }, 
            { type: 'â™¬', label: 'éŸ³ç¬¦' }, 
            { type: 'â˜¾', label: 'æœˆ' }, 
            { type: 'â—–', label: 'è‚‰çƒ' }, 
            { type: 'â™›', label: 'ç‹å† ' }, 
        ];

        // ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã‚¹ã‚¿ãƒ³ãƒ—ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿: { [dataURL]: { label, originalWidth, originalHeight } }
        const customStampMetadata = {};
        // ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: { [dataURL]: ImageInstance }
        const loadedImages = {};

        // --- çŠ¶æ…‹ç®¡ç† ---
        let currentMode = 'draw';
        let isDrawing = false;
        
        // æç”»å±¥æ­´: æ“ä½œã®é †åºã‚’è¨˜éŒ²ã™ã‚‹
        const history = [];
        let selectedStamp = null; 
        let selectedStampType = emojiStamps[0].type; 
        let currentStroke = null; 

        // ã‚¹ã‚¿ãƒ³ãƒ—å¤‰å½¢çŠ¶æ…‹
        let isDragging = false;
        let isRotating = false;
        let isScaling = false;
        let dragOffsetX = undefined; 
        let dragOffsetY = undefined; 
        let rotateInitialAngle = 0;
        let scaleInitialDistance = 0; 

        // ã‚¿ãƒƒãƒ—ä½ç½®ã¨ãƒ ãƒ¼ãƒ–ã®æœ‰ç„¡ã‚’è¨˜éŒ²ã™ã‚‹
        let lastDownPoint = null; 
        let isMovingOrTransforming = false; 
        let lastHitStamp = null; 
        
        let isTouchActive = false;


        // --- åˆæœŸè¨­å®šã¨ãƒªã‚µã‚¤ã‚ºå‡¦ç† ---

        function resizeCanvas() {
            const size = container.clientWidth;
            canvas.width = size;
            canvas.height = size;
            
            redrawCanvas();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- UIåˆæœŸåŒ–ã¨é¸æŠãƒ­ã‚¸ãƒƒã‚¯ ---

        /**
         * ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦UIã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
         * @param {string} mode - 'draw', 'erase', 'stamp' ã®ã„ãšã‚Œã‹
         */
        function setMode(mode) {
            currentMode = mode;
            
            // å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã¨è¨­å®šUIã‚’ãƒªã‚»ãƒƒãƒˆ
            drawModeBtn.classList.remove('active');
            eraseModeBtn.classList.remove('active');
            stampModeBtn.classList.remove('active');
            
            drawSettingsDiv.style.display = 'none';
            eraseSettingsDiv.style.display = 'none';
            stampSettingsDiv.style.display = 'none';
            stampPaletteDiv.style.display = 'none';
            
            selectedStamp = null; // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯ã‚¹ã‚¿ãƒ³ãƒ—é¸æŠã‚’è§£é™¤
            updateStampActionButtons(); // ãƒœã‚¿ãƒ³è¡¨ç¤ºã‚’æ›´æ–°

            if (mode === 'draw') {
                drawModeBtn.classList.add('active');
                drawSettingsDiv.style.display = 'flex';
            } else if (mode === 'erase') { 
                eraseModeBtn.classList.add('active');
                eraseSettingsDiv.style.display = 'flex';
            } else if (mode === 'stamp') {
                stampModeBtn.classList.add('active');
                stampSettingsDiv.style.display = 'flex'; 
                stampPaletteDiv.style.display = 'grid';
            }
            redrawCanvas(); 
        }
        
        /**
         * é¸æŠä¸­ã®ã‚¹ã‚¿ãƒ³ãƒ—æ“ä½œãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹
         */
        function updateStampActionButtons() {
            if (selectedStamp) {
                selectedStampActionsDiv.style.display = 'flex';
            } else {
                selectedStampActionsDiv.style.display = 'none';
            }
        }


        /**
         * ã‚¹ã‚¿ãƒ³ãƒ—ãƒœã‚¿ãƒ³ã‚’ä½œæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
         */
        function createStampButton(type, label, dataValue) {
            const btn = document.createElement('button');
            btn.className = 'stamp-button';
            btn.title = label;
            btn.setAttribute('data-stamp', dataValue);
            
            if (type.startsWith('data:image/')) {
                btn.innerHTML = `<img src="${type}" alt="${label}">`;
                btn.style.fontSize = '12px'; 
            } else {
                btn.innerHTML = type; 
            }

            btn.onclick = (e) => {
                e.stopPropagation(); 
                selectStampType(dataValue); 
            };
            return btn;
        }

        /**
         * é¸æŠçŠ¶æ…‹ã‚’è¨­å®šã™ã‚‹
         */
        function selectStampType(type) {
            selectedStampType = type;
            
            document.querySelectorAll('.stamp-button').forEach(b => b.classList.remove('selected'));

            const newBtn = document.querySelector(`.stamp-button[data-stamp='${type}']`);
            if (newBtn) {
                newBtn.classList.add('selected');
            } else if (!emojiStamps.find(s => s.type === type) && !customStampMetadata[type]) {
                selectedStampType = emojiStamps[0].type;
                document.querySelector(`.stamp-button[data-stamp='${selectedStampType}']`)?.classList.add('selected');
            }
        }


        function initStampPalette() {
            stampPaletteDiv.innerHTML = ''; 
            
            // 1. çµµæ–‡å­—ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ 
            emojiStamps.forEach(def => {
                const btn = createStampButton(def.type, def.label, def.type);
                stampPaletteDiv.appendChild(btn);
            });
            
            // 2. ã‚«ã‚¹ã‚¿ãƒ ç”»åƒã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ 
            Object.keys(customStampMetadata).forEach(dataUrl => {
                const metadata = customStampMetadata[dataUrl];
                const btn = createStampButton(dataUrl, metadata.label, dataUrl);
                stampPaletteDiv.appendChild(btn);
            });

            // 3. é¸æŠçŠ¶æ…‹ã‚’å†è¨­å®š
            selectStampType(selectedStampType);
        }

        // --- ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•ã¨å‰Šé™¤ãƒ­ã‚¸ãƒƒã‚¯ ---

        /**
         * é¸æŠä¸­ã®ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å±¥æ­´å†…ã®æ–°ã—ã„ä½ç½®ã«ç§»å‹•ã•ã›ã‚‹
         * @param {string} position - 'front' (æœ€å‰é¢) ã¾ãŸã¯ 'back' (æœ€èƒŒé¢)
         */
        function moveSelectedStampLayer(position) {
            if (!selectedStamp) return;

            const stampId = selectedStamp.id;
            const historyIndex = history.findIndex(item => 
                item.type === 'stamp' && item.data.id === stampId
            );

            if (historyIndex === -1) return;

            // 1. ç§»å‹•ã•ã›ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…åˆ—ã‹ã‚‰å‰Šé™¤
            const itemToMove = history.splice(historyIndex, 1)[0];

            if (position === 'front') {
                // æœ€å‰é¢ (ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å±¥æ­´ã®æœ«å°¾ã«è¿½åŠ )
                history.push(itemToMove);
            } else if (position === 'back') {
                // æœ€èƒŒé¢ (ã‚¹ã‚¿ãƒ³ãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­ã§ã®æœ€å‰é¢ã‚’æ¢ã™)
                
                let insertIndex = 0; // æç”»ã®ä¸Šã«é…ç½®ã•ã‚Œã‚‹ã‚ˆã†ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯0
                
                // æœ€åˆã®ã‚¹ã‚¿ãƒ³ãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã‚‹
                const firstStampIndex = history.findIndex(item => item.type === 'stamp');

                // æœ€åˆã®ã‚¹ã‚¿ãƒ³ãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã®ç›´å‰ã«æŒ¿å…¥ã™ã‚‹ã“ã¨ã§ã€æç”»ã®ä¸Šã«ãã‚‹ã‚¹ã‚¿ãƒ³ãƒ—ã®æœ€èƒŒé¢ã«ã™ã‚‹
                if (firstStampIndex !== -1) {
                    insertIndex = firstStampIndex;
                } else {
                    // ä»–ã«ã‚¹ã‚¿ãƒ³ãƒ—ãŒãªã„å ´åˆã€æœ€åˆã®æç”»ã‚¢ã‚¤ãƒ†ãƒ ã®ç›´å¾Œã«æŒ¿å…¥
                    // æç”»ã‚¢ã‚¤ãƒ†ãƒ ã¨ã‚¹ã‚¿ãƒ³ãƒ—ã‚¢ã‚¤ãƒ†ãƒ ãŒæ··åœ¨ã—ã¦ã„ã‚‹ã“ã¨ã‚’æƒ³å®š
                    // ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€ä»–ã®ã‚¹ã‚¿ãƒ³ãƒ—ã®ä¸­ã§æœ€ã‚‚èƒŒé¢ã«ãªã‚‹ã‚ˆã†ã«ã™ã‚‹
                    // ã™ã§ã«'splice'ã§å‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€'firstStampIndex'ã¯æ¬¡ã«æç”»ã•ã‚Œã‚‹ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æŒ‡ã™
                    insertIndex = firstStampIndex !== -1 ? firstStampIndex : history.length;
                }
                
                // 2. æ–°ã—ã„ä½ç½®ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒ¿å…¥
                history.splice(insertIndex, 0, itemToMove);
            }
            
            redrawCanvas();
            // ç§»å‹•å¾Œã‚‚é¸æŠçŠ¶æ…‹ã¯ç¶­æŒã•ã‚Œã‚‹
        }
        
        /**
         * é¸æŠä¸­ã®ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å‰Šé™¤ã™ã‚‹
         */
        function deleteSelectedStamp() {
            if (!selectedStamp) return;

            const stampId = selectedStamp.id;
            const historyIndex = history.findIndex(item => 
                item.type === 'stamp' && item.data.id === stampId
            );

            if (historyIndex !== -1) {
                history.splice(historyIndex, 1);
                selectedStamp = null; // å‰Šé™¤ã—ãŸã®ã§é¸æŠã‚’è§£é™¤
                redrawCanvas();
                updateStampActionButtons();
            }
        }


        // --- ä»–ã®æ©Ÿèƒ½ã®ãƒ­ã‚¸ãƒƒã‚¯ (çœç•¥ãƒ»æ—¢å­˜ã®ã‚‚ã®) ---

        /**
         * æŒ‡å®šã•ã‚ŒãŸIDã®ã‚¹ã‚¿ãƒ³ãƒ—ã‚’historyé…åˆ—ã®æœ«å°¾ã«ç§»å‹•ã•ã›ã‚‹
         */
        function bringStampToFront(stampId) {
            const historyIndex = history.findIndex(item => 
                item.type === 'stamp' && item.data.id === stampId
            );

            if (historyIndex !== -1) {
                const itemToMove = history.splice(historyIndex, 1)[0];
                history.push(itemToMove);
            }
        }

        function initFontSelector() {
             FONT_OPTIONS.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.family;
                option.textContent = opt.name;
                customTextFontSelect.appendChild(option);
            });
            customTextFontSelect.value = DEFAULT_FONT_FAMILY;
            
            customTextInput.oninput = updateCustomTextPreview;
            customTextFontSelect.onchange = updateCustomTextPreview;
            customTextSizeInput.oninput = () => {
                customTextSizeValueSpan.textContent = customTextSizeInput.value;
                updateCustomTextPreview();
            };
            updateCustomTextPreview(); 
        }
        
        function updateCustomTextPreview() {
            const text = customTextInput.value.trim() || "ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼";
            const size = parseInt(customTextSizeInput.value, 10);
            const font = `${size}pt ${customTextFontSelect.value}`;

            previewCtx.font = font;
            const metrics = previewCtx.measureText(text);
            
            const padding = 10;
            const textWidth = metrics.width + padding * 2;
            const textHeight = size * 1.5; 
            
            customTextPreviewCanvas.width = textWidth;
            customTextPreviewCanvas.height = textHeight;
            
            const pCtx = customTextPreviewCanvas.getContext('2d');
            
            pCtx.fillStyle = '#ffffff';
            pCtx.fillRect(0, 0, textWidth, textHeight);
            
            pCtx.fillStyle = '#000000';
            pCtx.font = font;
            pCtx.textAlign = 'left';
            pCtx.textBaseline = 'top';

            const baselineOffset = size * 0.2 + padding; 
            pCtx.fillText(text, padding, baselineOffset);
        }
        
        function handleGenerateStamp() {
            const text = customTextInput.value.trim();
            if (!text) {
                console.error("ã‚¹ã‚¿ãƒ³ãƒ—ã«ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                return;
            }
            
            updateCustomTextPreview();
            
            const dataUrl = customTextPreviewCanvas.toDataURL('image/png');
            
            const textWidth = customTextPreviewCanvas.width;
            const textHeight = customTextPreviewCanvas.height;
            
            customStampMetadata[dataUrl] = {
                label: text,
                originalWidth: textWidth, 
                originalHeight: textHeight,
            };
            
            const img = new Image();
            img.onload = () => {
                loadedImages[dataUrl] = img;
                initStampPalette(); 
                setMode('stamp'); 
                selectStampType(dataUrl); 
            };
            img.src = dataUrl;

            initStampPalette();
            selectStampType(dataUrl);
        }
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    
                    const originalWidth = img.width;
                    const originalHeight = img.height;

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = originalWidth;
                    tempCanvas.height = originalHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCtx.drawImage(img, 0, 0, originalWidth, originalHeight);

                    const imageData = tempCtx.getImageData(0, 0, originalWidth, originalHeight);
                    const data = imageData.data;

                    for (let i = 0; i < data.length; i += 4) {
                        const red = data[i];
                        const green = data[i + 1];
                        const blue = data[i + 2];

                        const avg = 0.299 * red + 0.587 * green + 0.114 * blue;

                        data[i] = avg;     
                        data[i + 1] = avg; 
                        data[i + 2] = avg; 
                    }

                    tempCtx.putImageData(imageData, 0, 0);

                    const processedDataUrl = tempCanvas.toDataURL('image/png');
                    
                    customStampMetadata[processedDataUrl] = {
                        label: file.name,
                        originalWidth: originalWidth, 
                        originalHeight: originalHeight,
                    };

                    const processedImg = new Image();
                    processedImg.onload = () => {
                        loadedImages[processedDataUrl] = processedImg;
                        
                        initStampPalette(); 
                        setMode('stamp'); 
                        selectStampType(processedDataUrl);
                        
                        imageFileInput.value = '';
                    };
                    processedImg.src = processedDataUrl;

                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- æç”»ãƒ­ã‚¸ãƒƒã‚¯ (çœç•¥ãƒ»æ—¢å­˜ã®ã‚‚ã®) ---

        function getMidpoint(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }

        function getDrawParams() {
            let color = '#000000'; 
            let baseWidth = parseFloat(baseLineWidthInput.value);
            
            if (currentMode === 'erase') { 
                color = '#ffffff'; 
                baseWidth = parseFloat(eraseLineWidthInput.value); 
            }

            const lineWidth = baseWidth * 2; 
            return { color, lineWidth: Math.max(MIN_LINE_WIDTH, lineWidth) };
        }
        
        function getCanvasPoint(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY, pressure = 0.5; 

            if (event.touches) {
                const touch = event.touches[0] || event.changedTouches[0];
                clientX = touch.clientX;
                clientY = touch.clientY;
                pressure = 0.5;
            } else {
                clientX = event.clientX;
                clientY = event.clientY; 
                pressure = 0.5;
                if (event.buttons !== 1 && event.type === 'mousemove') {
                    pressure = 0;
                }
            }

            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            
            return { x, y, pressure: Math.min(1.0, Math.max(0.0, pressure)), timestamp: Date.now() };
        }
        
        function startDraw(x, y, pressure, timestamp) {
            isDrawing = true;
            const { color, lineWidth } = getDrawParams();
            
            currentStroke = { 
                color: color, 
                points: [{ x, y, width: lineWidth, timestamp: timestamp }] 
            };
            
            history.push({ 
                type: 'draw', 
                data: currentStroke 
            });
        }

        function continueDraw(x, y, pressure, timestamp) {
            if (!isDrawing || (currentMode !== 'draw' && currentMode !== 'erase') || !currentStroke) return;

            const { lineWidth } = getDrawParams();
            currentStroke.points.push({ x, y, width: lineWidth, timestamp: timestamp });
            
            drawStrokeRealtime();
        }

        function endDraw() {
            if (isDrawing && currentStroke && currentStroke.points.length > 0) {
                redrawCanvas();
            }

            isDrawing = false;
            currentStroke = null;
        }

        function placeStamp(x, y) {
            const size = parseInt(stampSizeInput.value);
            
            let originalWidth = size;
            let originalHeight = size;
            
            let isImageStamp = selectedStampType.startsWith('data:image/');

            if (isImageStamp) {
                const metadata = customStampMetadata[selectedStampType];
                if (metadata) {
                    const aspectRatio = metadata.originalWidth / metadata.originalHeight;
                    if (metadata.originalWidth > metadata.originalHeight) {
                        originalWidth = size;
                        originalHeight = size / aspectRatio;
                    } else {
                        originalHeight = size;
                        originalWidth = size * aspectRatio;
                    }
                }
            } else {
                originalWidth = size;
                originalHeight = size;
            }

            let rotationAngle = 0;
            const rotationMode = rotationModeSelect.value;
            
            if (rotationMode === 'random') {
                rotationAngle = Math.random() * 2 * Math.PI; 
            } else {
                const angleDeg = parseInt(fixedRotationAngleInput.value, 10);
                rotationAngle = angleDeg * (Math.PI / 180); 
            }

            const newStamp = {
                id: Date.now(), 
                type: selectedStampType, 
                x: x, 
                y: y,
                scale: 1,
                rotation: rotationAngle, 
                baseSize: size, 
                originalWidth: originalWidth, 
                originalHeight: originalHeight
            };
            history.push({ type: 'stamp', data: newStamp });
            selectedStamp = newStamp;
            redrawCanvas();
            updateStampActionButtons(); // æ–°ã—ã„ã‚¹ã‚¿ãƒ³ãƒ—ãŒé¸æŠã•ã‚ŒãŸã®ã§æ›´æ–°
        }


        // --- å…¨ä½“æç”»é–¢æ•° (çœç•¥ãƒ»æ—¢å­˜ã®ã‚‚ã®) ---

        function redrawCanvas() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            history.forEach(item => {
                if (item.type === 'draw') {
                    ctx.fillStyle = item.data.color; 
                    drawVariableWidthStroke(item.data.points);
                } else if (item.type === 'stamp') {
                    drawStamp(item.data);
                }
            });
        }
        
        function drawVariableWidthStroke(points) {
            const numPoints = points.length;
            if (numPoints < 2) {
                if (numPoints === 1) {
                    const p = points[0];
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.width / 2, 0, Math.PI * 2, true);
                    ctx.fill();
                }
                return;
            }

            const outlinePoints = []; 
            for (let i = 0; i < numPoints; i++) {
                const p = points[i];
                const pPrev = points[i - 1];
                const pNext = points[i + 1];

                let dx = 0, dy = 0;

                if (pPrev && pNext) {
                    dx = pNext.x - pPrev.x;
                    dy = pNext.y - pPrev.y;
                } else if (pNext) {
                    dx = pNext.x - p.x;
                    dy = pNext.y - p.y;
                } else if (pPrev) {
                    dx = p.x - pPrev.x;
                    dy = p.y - pPrev.y;
                }

                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const perpX = -(dy / dist);
                    const perpY = (dx / dist);
                    const w = p.width / 2;

                    const topX = p.x + perpX * w;
                    const topY = p.y + perpY * w;
                    const bottomX = p.x - perpX * w;
                    const bottomY = p.y - perpY * w;

                    outlinePoints.push({ topX, topY, bottomX, bottomY, x: p.x, y: p.y, width: p.width });
                } else {
                    if(i > 0 && outlinePoints[i-1]) {
                         outlinePoints.push(outlinePoints[i-1]);
                    } else {
                         outlinePoints.push(null);
                    }
                }
            }
            
            const validOutlinePoints = outlinePoints.filter(p => p !== null);
            const validNumPoints = validOutlinePoints.length;

            if (validNumPoints < 2) {
                const p = points[0];
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.width / 2, 0, Math.PI * 2, true);
                ctx.fill();
                return;
            }

            ctx.beginPath();
            
            const p0 = validOutlinePoints[0];
            ctx.moveTo(p0.topX, p0.topY); 
            for (let i = 0; i < validNumPoints - 1; i++) { 
                const piTop = validOutlinePoints[i];
                const piNextTop = validOutlinePoints[i+1];
                
                if (i === validNumPoints - 2) {
                    ctx.quadraticCurveTo(piTop.topX, piTop.topY, piNextTop.topX, piNextTop.topY);
                } else {
                    let nextAnchorTop = getMidpoint({x: piTop.topX, y: piTop.topY}, {x: piNextTop.topX, y: piNextTop.topY});
                    ctx.quadraticCurveTo(piTop.topX, piTop.topY, nextAnchorTop.x, nextAnchorTop.y);
                }
            }

            const pn = validOutlinePoints[validNumPoints - 1];
            ctx.lineTo(pn.bottomX, pn.bottomY); 

            for (let i = validNumPoints - 1; i > 0; i--) { 
                const piBottom = validOutlinePoints[i];
                const piPrevBottom = validOutlinePoints[i-1];
                
                if (i === 1) {
                    ctx.quadraticCurveTo(piBottom.bottomX, piBottom.bottomY, piPrevBottom.bottomX, piPrevBottom.bottomY);
                } else {
                    let nextAnchorBottom = getMidpoint({x: piBottom.bottomX, y: piBottom.bottomY}, {x: piPrevBottom.bottomX, y: piPrevBottom.bottomY});
                    ctx.quadraticCurveTo(piBottom.bottomX, piBottom.bottomY, nextAnchorBottom.x, nextAnchorBottom.y);
                }
            }
            
            ctx.lineTo(p0.topX, p0.topY); 
            ctx.fill(); 

            const pStart = points[0];
            ctx.beginPath();
            ctx.arc(pStart.x, pStart.y, pStart.width / 2, 0, Math.PI * 2);
            ctx.fill();
            
            const pEnd = points[points.length - 1];
            ctx.beginPath();
            ctx.arc(pEnd.x, pEnd.y, pEnd.width / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawStamp(s) {
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.rotate(s.rotation);
            ctx.scale(s.scale, s.scale);

            ctx.fillStyle = '#000000';
            
            const isImageStamp = s.type.startsWith('data:image/');

            if (isImageStamp) {
                const img = loadedImages[s.type];
                if (img) {
                    ctx.drawImage(img, -s.originalWidth / 2, -s.originalHeight / 2, s.originalWidth, s.originalHeight);
                } else {
                    ctx.font = `20px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('...', 0, 0);
                }
            } else {
                const FONT_SIZE = s.baseSize;
                ctx.font = `${FONT_SIZE}px Arial, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(s.type, 0, FONT_SIZE * 0.05); // çµµæ–‡å­—ã®æç”»ä½ç½®å¾®èª¿æ•´
            }

            if (s === selectedStamp && currentMode === 'stamp') {
                const effectiveWidth = s.originalWidth;
                const effectiveHeight = s.originalHeight;
                
                ctx.strokeStyle = 'red'; 
                ctx.lineWidth = 2 / s.scale; 
                
                ctx.strokeRect(-effectiveWidth / 2, -effectiveHeight / 2, effectiveWidth, effectiveHeight);
                
                const handleSize = 8 / s.scale; 

                // 1. ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ãƒãƒ³ãƒ‰ãƒ« (å³ä¸‹) - é’è‰²
                const scaleHandleX = effectiveWidth / 2;
                const scaleHandleY = effectiveHeight / 2;
                
                ctx.fillStyle = 'blue'; 
                ctx.beginPath();
                ctx.arc(scaleHandleX, scaleHandleY, handleSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 2. å›è»¢ãƒãƒ³ãƒ‰ãƒ« (å³ä¸Š) - ç·‘è‰²
                const rotateHandleX = effectiveWidth / 2;
                const rotateHandleY = -effectiveHeight / 2;
                
                ctx.fillStyle = 'green'; 
                ctx.beginPath();
                ctx.arc(rotateHandleX, rotateHandleY, handleSize, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }
        
        function drawStrokeRealtime() {
            redrawCanvas(); 
        }

        function hitTestHandle(x, y) {
            if (!selectedStamp) return null;

            const s = selectedStamp;
            
            // 1. ã‚°ãƒ­ãƒ¼ãƒãƒ«åº§æ¨™ã‹ã‚‰ã‚¹ã‚¿ãƒ³ãƒ—ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã¸å¤‰æ›
            const dx = x - s.x;
            const dy = y - s.y;
            const cos = Math.cos(-s.rotation);
            const sin = Math.sin(-s.rotation);
            
            const localX = (dx * cos) - (dy * sin);
            const localY = (dx * sin) + (dy * cos);
            
            const unscaledLocalX = localX / s.scale;
            const unscaledLocalY = localY / s.scale;

            const halfOriginalW = s.originalWidth / 2;
            const halfOriginalH = s.originalHeight / 2;

            const tolerance = 20; 

            // 2. å³ä¸‹ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ãƒãƒ³ãƒ‰ãƒ« (Scale Handle) ã®åˆ¤å®š (é’ã„ä¸¸)
            const scaleHandleX = halfOriginalW;
            const scaleHandleY = halfOriginalH;
            
            if (unscaledLocalX > scaleHandleX - tolerance && unscaledLocalX < scaleHandleX + tolerance &&
                unscaledLocalY > scaleHandleY - tolerance && unscaledLocalY < scaleHandleY + tolerance) {
                return 'scale';
            }
            
            // 3. å³ä¸Šå›è»¢ãƒãƒ³ãƒ‰ãƒ« (Rotate Handle) ã®åˆ¤å®š (ç·‘ã®ä¸¸)
            const rotateHandleX = halfOriginalW;
            const rotateHandleY = -halfOriginalH;
            
            if (unscaledLocalX > rotateHandleX - tolerance && unscaledLocalX < rotateHandleX + tolerance &&
                unscaledLocalY > rotateHandleY - tolerance && unscaledLocalY < rotateHandleY + tolerance) {
                return 'rotate';
            }

            return null;
        }

        function hitTestStamp(x, y) {
            const stampItems = history.filter(item => item.type === 'stamp').map(item => item.data);
            
            for (let i = stampItems.length - 1; i >= 0; i--) {
                const s = stampItems[i];
                
                // æç”»ã‚µã‚¤ã‚º (ã‚¹ã‚¿ãƒ³ãƒ—ã‚µã‚¤ã‚º * ã‚¹ã‚±ãƒ¼ãƒ«) ã‚’ä½¿ç”¨
                const effectiveWidth = s.originalWidth * s.scale; 
                const effectiveHeight = s.originalHeight * s.scale;
                
                // ç°¡æ˜“çš„ãªãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ (å›è»¢ã‚’ç„¡è¦–)
                const padding = 10; 
                const halfWidth = effectiveWidth / 2 + padding;
                const halfHeight = effectiveHeight / 2 + padding;
                
                if (x > s.x - halfWidth && x < s.x + halfWidth &&
                    y > s.y - halfHeight && y < s.y + halfHeight) {
                    return s;
                }
            }
            return null;
        }


        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© (çœç•¥ãƒ»æ—¢å­˜ã®ã‚‚ã®) ---

        function handleDown(e, x, y, pressure, timestamp) {
            
            if (isTouchActive && !e.touches && currentMode !== 'draw' && currentMode !== 'erase') {
                 return;
            }

            lastDownPoint = { x, y }; 
            isMovingOrTransforming = false; 
            
            dragOffsetX = undefined;
            dragOffsetY = undefined;
            isDragging = false; 
            lastHitStamp = null; 
            
            if ((currentMode === 'draw' || currentMode === 'erase') && pressure >= MIN_PRESSURE_THRESHOLD) { 
                if (e.touches && e.touches.length === 1) e.preventDefault();
                startDraw(x, y, pressure, timestamp);
            } else if (currentMode === 'stamp') {
                
                const handleHit = hitTestHandle(x, y); 
                
                if (handleHit === 'scale') {
                    if(selectedStamp) {
                        bringStampToFront(selectedStamp.id); 
                        isScaling = true;
                        isMovingOrTransforming = true; 
                        dragOffsetX = x - selectedStamp.x; 
                        dragOffsetY = y - selectedStamp.y; 
                        selectedStamp.initialScale = selectedStamp.scale; 
                    }
                } else if (handleHit === 'rotate') {
                    if(selectedStamp) {
                        bringStampToFront(selectedStamp.id); 
                        isRotating = true;
                        isMovingOrTransforming = true; 
                        rotateInitialAngle = Math.atan2(y - selectedStamp.y, x - selectedStamp.x);
                        dragOffsetX = undefined;
                        dragOffsetY = undefined;
                    }
                } else {
                    const hit = hitTestStamp(x, y);

                    if (hit) {
                        lastHitStamp = hit; 
                        let shouldPrepareForDrag = false;

                        if (selectedStamp && selectedStamp.id === hit.id) {
                            selectedStamp = null;
                        } else {
                            selectedStamp = hit;
                            shouldPrepareForDrag = true;
                            bringStampToFront(hit.id); 
                        }
                        
                        redrawCanvas();
                        updateStampActionButtons(); // ã“ã“ã§æ›´æ–°

                        if (shouldPrepareForDrag) {
                            dragOffsetX = x - hit.x;
                            dragOffsetY = y - hit.y;
                        } else {
                            dragOffsetX = undefined;
                            dragOffsetY = undefined;
                        }
                        
                    } else {
                         selectedStamp = null;
                         redrawCanvas();
                         updateStampActionButtons(); // ã“ã“ã§æ›´æ–°
                    }
                    
                    if (e.touches && e.touches.length === 2) {
                        if (!handleHit) {
                            e.preventDefault();
                            const p1 = getCanvasPoint({ touches: [e.touches[0]] });
                            const p2 = getCanvasPoint({ touches: [e.touches[1]] });

                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            scaleInitialDistance = Math.sqrt(dx * dx + dy * dy);
                            rotateInitialAngle = Math.atan2(dy, dx);
                            
                            selectedStamp.initialScale = selectedStamp.scale;

                            isDragging = false; 
                            isRotating = true; 
                            isScaling = true; 
                            isMovingOrTransforming = true; 
                        }
                    }
                }
            }
        }

        function handleMove(e, x, y, pressure, timestamp) {
            if (currentMode === 'draw' || currentMode === 'erase') { 
                if (isDrawing) {
                    if (e.touches && e.touches.length === 1) e.preventDefault();
                    continueDraw(x, y, pressure, timestamp);
                }
            } else if (currentMode === 'stamp' && selectedStamp) {
                
                if (isRotating || isScaling) {
                    isMovingOrTransforming = true; 
                }

                if (!isScaling && !isRotating && dragOffsetX !== undefined) { 
                    if (!isDragging && lastDownPoint && (Math.abs(x - lastDownPoint.x) > 5 || Math.abs(y - lastDownPoint.y) > 5)) {
                        isDragging = true;
                        isMovingOrTransforming = true;
                    }
                }

                if (isDragging) {
                    if (e.touches && e.touches.length === 1) e.preventDefault();
                    selectedStamp.x = x - dragOffsetX;
                    selectedStamp.y = y - dragOffsetY;
                    redrawCanvas();
                    isMovingOrTransforming = true; 
                } else if (isScaling && !isDragging && !isRotating) {
                    if (e.touches && e.touches.length === 1) e.preventDefault();
                    
                    const currentDx = x - selectedStamp.x;
                    const currentDy = y - selectedStamp.y;
                    const currentDistance = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
                    
                    const initialDistance = Math.sqrt(dragOffsetX * dragOffsetX + dragOffsetY * dragOffsetY);
                    
                    if (initialDistance > 10) { 
                        const scaleFactor = (currentDistance / initialDistance);
                        let newScale = selectedStamp.initialScale * scaleFactor;
                        
                        selectedStamp.scale = Math.max(0.1, Math.min(10, newScale)); 
                    }
                    redrawCanvas();

                } else if (isRotating && !isScaling && !isDragging) { 
                    if (e.touches && e.touches.length === 1) e.preventDefault();
                    
                    const currentAngle = Math.atan2(y - selectedStamp.y, x - selectedStamp.x);
                    
                    const rotationDelta = currentAngle - rotateInitialAngle;
                    selectedStamp.rotation += rotationDelta;
                    rotateInitialAngle = currentAngle; 
                    
                    redrawCanvas();
                } else if (isRotating && isScaling && e.touches && e.touches.length === 2) {
                    e.preventDefault();
                    const p1 = getCanvasPoint({ touches: [e.touches[0]] });
                    const p2 = getCanvasPoint({ touches: [e.touches[1]] });
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    const currentAngle = Math.atan2(dy, dx);

                    if (scaleInitialDistance > 0) {
                        const scaleFactor = (currentDistance / scaleInitialDistance);
                        let newScale = selectedStamp.initialScale * scaleFactor;

                        selectedStamp.scale = Math.max(0.1, Math.min(10, newScale));
                        scaleInitialDistance = currentDistance; 
                    }

                    const rotationDelta = currentAngle - rotateInitialAngle;
                    selectedStamp.rotation += rotationDelta;
                    rotateInitialAngle = currentAngle;

                    redrawCanvas();
                }
            }
        }

        function handleUp() {
            endDraw();

            if (currentMode === 'stamp' && !isMovingOrTransforming && lastDownPoint) {
                if (!lastHitStamp) { 
                    placeStamp(lastDownPoint.x, lastDownPoint.y);
                }
            }
            
            isDragging = false;
            isRotating = false;
            isScaling = false;
            
            if (selectedStamp) {
                delete selectedStamp.initialScale;
            }

            isMovingOrTransforming = false;
            lastDownPoint = null;
            dragOffsetX = undefined;
            dragOffsetY = undefined;
            
            lastHitStamp = null;
        }

        // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆã¯çœç•¥ (æ—¢å­˜ã®ã¾ã¾)
        canvas.addEventListener('mousedown', (e) => handleDown(e, getCanvasPoint(e).x, getCanvasPoint(e).y, getCanvasPoint(e).pressure, getCanvasPoint(e).timestamp));
        canvas.addEventListener('mousemove', (e) => handleMove(e, getCanvasPoint(e).x, getCanvasPoint(e).y, getCanvasPoint(e).pressure, getCanvasPoint(e).timestamp));
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);


        function handleMouseDown(e) {
            const { x, y, pressure, timestamp } = getCanvasPoint(e);
            handleDown(e, x, y, pressure, timestamp);
        }

        function handleMouseMove(e) {
            const { x, y, pressure, timestamp } = getCanvasPoint(e);
            handleMove(e, x, y, pressure, timestamp);
        }

        function handleMouseUp(e) {
            if (isTouchActive) {
                return;
            }
            handleUp();
        }

        function handleTouchStart(e) {
            const { x, y, pressure, timestamp } = getCanvasPoint(e);
            isTouchActive = true; 
            handleDown(e, x, y, pressure, timestamp);
        }

        function handleTouchMove(e) {
            const { x, y, pressure, timestamp } = getCanvasPoint(e);
            handleMove(e, x, y, pressure, timestamp);
        }

        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                handleUp(); 
                setTimeout(() => {
                    isTouchActive = false; 
                }, 50);
            }
        }


        // --- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³å‡¦ç† ---

        undoBtn.onclick = () => {
            if (history.length > 0) {
                history.pop(); 
                selectedStamp = null; 
                redrawCanvas();
                updateStampActionButtons();
                outputArea.style.display = 'none'; 
            }
        };
        
        // â˜…æ–°ã—ãè¿½åŠ ã•ã‚ŒãŸãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        sendToBackBtn.onclick = () => moveSelectedStampLayer('back');
        sendToFrontBtn.onclick = () => moveSelectedStampLayer('front');
        deleteStampBtn.onclick = deleteSelectedStamp;


        function handleDownload() {
            console.log("ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ç”»åƒç”Ÿæˆå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...");
            
            const tempSelected = selectedStamp;
            selectedStamp = null; 
            redrawCanvas();

            const width = canvas.width;
            const height = canvas.height;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(canvas, 0, 0);

            try {
                const imageData = tempCtx.getImageData(0, 0, width, height);
                const data = imageData.data; 
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (r === 255 && g === 255 && b === 255) {
                        data[i + 3] = 0; 
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
            } catch (e) {
                console.error("ãƒ”ã‚¯ã‚»ãƒ«æ“ä½œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", e);
            }

            const dataUrl = tempCanvas.toDataURL('image/png');

            previewImage.src = dataUrl;
            outputArea.style.display = 'block'; 
            outputArea.scrollIntoView({ behavior: 'smooth' }); 

            selectedStamp = tempSelected;
            redrawCanvas();
        }

        downloadBtn.onclick = handleDownload;

        // UIã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        baseLineWidthInput.oninput = (e) => {
            baseLineWidthValueSpan.textContent = parseFloat(e.target.value).toFixed(1);
        };
        
        eraseLineWidthInput.oninput = (e) => { 
            eraseLineWidthValueSpan.textContent = e.target.value;
        };

        stampSizeInput.oninput = (e) => {
            stampSizeValueSpan.textContent = e.target.value;
        };
        
        rotationModeSelect.onchange = () => {
            fixedRotationControlDiv.style.display = rotationModeSelect.value === 'fixed' ? 'flex' : 'none';
        };
        fixedRotationAngleInput.oninput = () => {
            fixedRotationValueSpan.textContent = fixedRotationAngleInput.value;
        };
        
        drawModeBtn.onclick = () => setMode('draw');
        eraseModeBtn.onclick = () => setMode('erase'); 
        stampModeBtn.onclick = () => setMode('stamp');
        generateStampBtn.onclick = handleGenerateStamp;
        
        imageFileInput.onchange = handleImageUpload; 

        // åˆæœŸåŒ–å‡¦ç†ã®å®Ÿè¡Œ
        initFontSelector();
        initStampPalette();
        setMode('draw'); 
    });
</script>
</body>
</html>